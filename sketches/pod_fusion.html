<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pod Fusion</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Lora:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --anthropic-dark: #141413;
            --anthropic-light: #faf9f5;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #0d0d1a 0%, #1a1a2e 50%, #0d0d1a 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            display: flex;
            min-height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        .sidebar {
            width: 300px;
            flex-shrink: 0;
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(10px);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .sidebar h1 {
            font-family: 'Lora', serif;
            font-size: 26px;
            font-weight: 500;
            background: linear-gradient(135deg, #ff9de4, #7eb8ff, #64f4d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .sidebar .subtitle {
            color: rgba(255, 255, 255, 0.5);
            font-size: 13px;
            margin-bottom: 28px;
            line-height: 1.5;
        }

        .control-section { margin-bottom: 28px; }

        .control-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-section h3::before {
            content: '◉';
            color: #64f4d4;
            font-size: 10px;
        }

        .seed-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.08);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            color: #fff;
        }

        .seed-input:focus {
            outline: none;
            border-color: #64f4d4;
            box-shadow: 0 0 15px rgba(100, 244, 212, 0.2);
        }

        .seed-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .control-group { margin-bottom: 16px; }

        .control-group label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-container input[type="range"] {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #64f4d4, #7eb8ff);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 244, 212, 0.5);
        }

        .value-display {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            min-width: 40px;
            text-align: right;
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-picker-container input[type="color"] {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
            padding: 0;
        }

        .color-picker-container input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker-container input[type="color"]::-webkit-color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
        }

        .color-value {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        select {
            width: 100%;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            outline: none;
        }

        select:focus {
            border-color: #64f4d4;
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .palette-preview {
            display: flex;
            gap: 6px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .palette-color {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.2s ease;
        }

        .palette-color:hover {
            transform: scale(1.15);
        }

        .preset-colors {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .preset-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 4px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .preset-btn.active {
            border-color: #64f4d4;
            background: rgba(100, 244, 212, 0.1);
        }

        .preset-swatch {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .preset-name {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            line-height: 1.2;
        }

        .button {
            background: linear-gradient(135deg, #64f4d4, #7eb8ff);
            color: #0d0d1a;
            border: none;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 244, 212, 0.4);
        }

        .button.secondary {
            background: linear-gradient(135deg, #7eb8ff, #b088f4);
        }

        .button.tertiary {
            background: linear-gradient(135deg, #ff9de4, #ffd484);
        }

        .button-row {
            display: flex;
            gap: 8px;
        }

        .button-row .button { flex: 1; }

        .stats {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 6px;
        }

        .stat-row:last-child { margin-bottom: 0; }

        .stat-value {
            color: #64f4d4;
            font-family: 'Courier New', monospace;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 0;
        }

        #canvas-container {
            width: 100%;
            max-width: 900px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6), 0 0 60px rgba(100, 244, 212, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        #canvas-container canvas {
            display: block;
            width: 100% !important;
            height: auto !important;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.5);
            padding: 100px;
        }

        @media (max-width: 700px) {
            .container { flex-direction: column; }
            .sidebar { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>Pod Fusion</h1>
            <div class="subtitle">1つのPodが出会い、融合し、新しいPodとなって連鎖的に成長する</div>

            <div class="control-section">
                <h3>Seed</h3>
                <input type="number" id="seed-input" class="seed-input" value="42" onchange="updateSeed()">
                <div class="seed-controls">
                    <button class="button secondary" onclick="previousSeed()">← Prev</button>
                    <button class="button secondary" onclick="nextSeed()">Next →</button>
                </div>
                <button class="button tertiary" onclick="randomSeedAndUpdate()">◉ Random</button>
            </div>

            <div class="control-section">
                <h3>Theme Color</h3>
                <div class="control-group">
                    <label>Basic</label>
                    <div class="preset-colors" id="preset-basic"></div>
                </div>
                <div class="control-group">
                    <label>Splatoon</label>
                    <div class="preset-colors" id="preset-splatoon"></div>
                </div>
                <div class="control-group">
                    <label>Color Harmony</label>
                    <select id="color-harmony" onchange="updateColorHarmony(this.value)">
                        <option value="analogous">Analogous (類似色)</option>
                        <option value="complementary">Complementary (補色)</option>
                        <option value="triadic">Triadic (三色)</option>
                        <option value="tetradic">Tetradic (四色)</option>
                        <option value="monochromatic">Monochromatic (同系色)</option>
                    </select>
                </div>
                <div class="palette-preview" id="palette-preview"></div>
            </div>

            <div class="control-section">
                <h3>Sphere</h3>

                <div class="control-group">
                    <label>Initial Pods</label>
                    <div class="slider-container">
                        <input type="range" id="initialPods" min="140" max="300" step="20" value="220" oninput="updateParam('initialPods', this.value)">
                        <span class="value-display" id="initialPods-value">220</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Sphere Rotation</label>
                    <div class="slider-container">
                        <input type="range" id="rotationSpeed" min="0.02" max="0.18" step="0.02" value="0.1" oninput="updateParam('rotationSpeed', this.value)">
                        <span class="value-display" id="rotationSpeed-value">0.1</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Fusion Distance</label>
                    <div class="slider-container">
                        <input type="range" id="fusionDistance" min="5" max="15" step="1" value="10" oninput="updateParam('fusionDistance', this.value)">
                        <span class="value-display" id="fusionDistance-value">10</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Attraction Force</label>
                    <div class="slider-container">
                        <input type="range" id="attractionForce" min="0.05" max="0.35" step="0.05" value="0.2" oninput="updateParam('attractionForce', this.value)">
                        <span class="value-display" id="attractionForce-value">0.2</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Pod Speed</label>
                    <div class="slider-container">
                        <input type="range" id="podSpeed" min="0.1" max="0.3" step="0.02" value="0.2" oninput="updateParam('podSpeed', this.value)">
                        <span class="value-display" id="podSpeed-value">0.2</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Leave Chance</label>
                    <div class="slider-container">
                        <input type="range" id="leaveChance" min="0.02" max="0.18" step="0.02" value="0.1" oninput="updateParam('leaveChance', this.value)">
                        <span class="value-display" id="leaveChance-value">0.1</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>Statistics</h3>
                <div class="stats">
                    <div class="stat-row">
                        <span>Active Pods</span>
                        <span class="stat-value" id="stat-pods">12</span>
                    </div>
                    <div class="stat-row">
                        <span>Total Fusions</span>
                        <span class="stat-value" id="stat-fusions">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Largest Pod</span>
                        <span class="stat-value" id="stat-largest">1</span>
                    </div>
                    <div class="stat-row">
                        <span>Total Leaves</span>
                        <span class="stat-value" id="stat-leaves">0</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>Actions</h3>
                <div class="button-row">
                    <button class="button" onclick="resetParameters()">Reset</button>
                    <button class="button secondary" onclick="downloadImage()">Download</button>
                </div>
            </div>
        </div>

        <div class="canvas-area">
            <div id="canvas-container">
                <div class="loading">◉ Initializing Pod Universe...</div>
            </div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════════
        // POD FUSION - Pods merging in a 3D sphere
        // ═══════════════════════════════════════════════════════════════════════

        let params = {
            seed: 42,
            initialPods: 220,
            rotationSpeed: 0.1,
            fusionDistance: 10,
            attractionForce: 0.2,
            podSpeed: 0.2,
            leaveChance: 0.1,
            themeColor: '#ffb7c5',
            colorHarmony: 'analogous',
            colorPalette: []
        };

        let defaultParams = JSON.parse(JSON.stringify(params));

        // System
        let pods = [];
        let fusionEffects = [];
        let leaveEffects = [];
        let energyBridges = [];
        let ambientParticles = [];
        let particleTrails = [];  // For particle trail effect
        let sphereRadius = 300;
        let rotationX = 0;
        let rotationY = 0;
        let time = 0;
        let totalFusions = 0;
        let totalLeaves = 0;
        let breathPhase = 0;  // For breathing pulsation

        function setup() {
            let canvas = createCanvas(900, 900);
            canvas.parent('canvas-container');
            colorMode(RGB, 255, 255, 255, 1);
            initializeSystem();
            document.querySelector('.loading').style.display = 'none';
        }

        function initializeSystem() {
            randomSeed(params.seed);
            noiseSeed(params.seed);

            pods = [];
            fusionEffects = [];
            leaveEffects = [];
            energyBridges = [];
            ambientParticles = [];
            particleTrails = [];
            totalFusions = 0;
            totalLeaves = 0;
            time = 0;
            breathPhase = 0;

            sphereRadius = min(width, height) * 0.32;

            // Create initial pods distributed throughout 3D sphere volume
            for (let i = 0; i < params.initialPods; i++) {
                // Distribute throughout the sphere volume, not just surface
                let r = random(sphereRadius * 0.2, sphereRadius * 0.85);
                let theta = random(TWO_PI);
                let phi = acos(2 * random() - 1); // Uniform distribution on sphere

                let initPos = {
                    x: r * sin(phi) * cos(theta),
                    y: r * sin(phi) * sin(theta),
                    z: r * cos(phi)
                };
                createPod(initPos, null);
            }

            // Create ambient particles inside sphere
            // Fewer, larger "trust particles" for atmospheric feel
            for (let i = 0; i < 120; i++) {
                let r = random(sphereRadius * 0.3, sphereRadius * 0.95);
                let theta = random(TWO_PI);
                let phi = random(PI);

                // Assign a color from the palette for each particle
                let colorIndex = floor(random(params.colorPalette.length));

                ambientParticles.push({
                    x: r * sin(phi) * cos(theta),
                    y: r * sin(phi) * sin(theta),
                    z: r * cos(phi),
                    size: random(3, 7),  // Larger particles
                    alpha: random(0.15, 0.35),  // Softer alpha
                    speed: random(0.001, 0.004),  // Slower, more ethereal movement
                    colorIndex: colorIndex  // For blendColors-based coloring
                });
            }

            updateStats();
        }

        function createPod(position, colors) {
            let x, y, z;

            if (position) {
                x = position.x;
                y = position.y;
                z = position.z;
            } else {
                // Random position on sphere surface
                let theta = random(TWO_PI);
                let phi = random(PI);
                let r = sphereRadius * random(0.4, 0.9);
                x = r * sin(phi) * cos(theta);
                y = r * sin(phi) * sin(theta);
                z = r * cos(phi);
            }

            let podColors;
            if (colors) {
                podColors = colors;
            } else {
                let colorIndex = floor(random(params.colorPalette.length));
                podColors = [params.colorPalette[colorIndex]];
            }

            // Velocity tangent to sphere
            let toCenter = createVector(-x, -y, -z).normalize();
            let randomDir = createVector(random(-1, 1), random(-1, 1), random(-1, 1)).normalize();
            let velocity = toCenter.cross(randomDir).normalize().mult(random(0.3, 0.8));

            pods.push({
                x: x,
                y: y,
                z: z,
                vx: velocity.x,
                vy: velocity.y,
                vz: velocity.z,
                colors: podColors,
                memberCount: colors ? colors.length : 1,
                size: 12 + (colors ? colors.length * 5 : 0),
                phase: random(TWO_PI),
                pulseSpeed: random(0.03, 0.06),
                targetPod: null,
                attracting: false
            });
        }

        function draw() {
            // Background
            background(13, 13, 26);

            // Vignette effect - darker edges, brighter center
            drawVignette();

            time += 0.016;
            breathPhase += 0.02;  // Breathing animation speed

            // Rotate sphere view - more dynamic rotation
            rotationY += 0.004 * params.rotationSpeed;
            rotationX = sin(time * 0.15) * 0.25 + 0.2; // Tilted view with oscillation

            translate(width / 2, height / 2);

            // Sort pods by z for proper depth rendering
            let sortedPods = [...pods].map((p, i) => ({...p, index: i}));

            // Apply rotation to get screen positions
            for (let p of sortedPods) {
                let rotated = rotatePoint(p.x, p.y, p.z);
                p.screenX = rotated.x;
                p.screenY = rotated.y;
                p.screenZ = rotated.z;
            }

            sortedPods.sort((a, b) => a.screenZ - b.screenZ);

            // Update physics
            updatePods();

            // Draw ambient particles with trails
            drawAmbientParticles();
            drawParticleTrails();

            // Draw pods (back to front)
            for (let p of sortedPods) {
                drawPod(p);
            }

            // Draw fusion effects
            drawFusionEffects();

            // Draw leave effects
            drawLeaveEffects();

            // Check for fusions
            checkFusions();

            // Check for leaves
            checkLeaves();

            updateStats();
        }

        // ═══════════════════════════════════════════════════════════════════════
        // Background World Effects
        // ═══════════════════════════════════════════════════════════════════════

        function drawParticleTrails() {
            // Draw fading trails for moving particles
            noStroke();

            // Update and draw trails
            for (let i = particleTrails.length - 1; i >= 0; i--) {
                let trail = particleTrails[i];
                trail.life--;

                if (trail.life <= 0) {
                    particleTrails.splice(i, 1);
                    continue;
                }

                let alpha = (trail.life / trail.maxLife) * 0.3;
                let size = trail.size * (trail.life / trail.maxLife);

                fill(trail.r, trail.g, trail.b, alpha);
                ellipse(trail.x, trail.y, size, size);
            }
        }

        function rotatePoint(x, y, z) {
            // Rotate around Y axis
            let cosY = cos(rotationY);
            let sinY = sin(rotationY);
            let x1 = x * cosY - z * sinY;
            let z1 = x * sinY + z * cosY;

            // Rotate around X axis
            let cosX = cos(rotationX);
            let sinX = sin(rotationX);
            let y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX;

            return { x: x1, y: y1, z: z2 };
        }

        function drawVignette() {
            // Create vignette effect - darker edges focus attention to center
            push();
            noStroke();
            let maxDist = sqrt(sq(width/2) + sq(height/2));

            // Draw radial gradient from center (transparent) to edges (dark)
            for (let i = 20; i >= 0; i--) {
                let ratio = i / 20;
                let radius = maxDist * (0.4 + ratio * 0.8);
                let alpha = ratio * ratio * 0.4; // Quadratic falloff for softer vignette
                fill(5, 5, 15, alpha);
                ellipse(width/2, height/2, radius * 2, radius * 2);
            }
            pop();
        }

        function drawAmbientParticles() {
            noStroke();

            // Get blended color from palette for "trust particles" feel
            let blendedColor = blendColors(params.colorPalette);
            let blendedRgb = hexToRgb(blendedColor);

            for (let i = 0; i < ambientParticles.length; i++) {
                let p = ambientParticles[i];

                // Slow ethereal orbit
                let angle = time * p.speed;
                let cosA = cos(angle);
                let sinA = sin(angle);
                let newX = p.x * cosA - p.z * sinA;
                let newZ = p.x * sinA + p.z * cosA;

                let rotated = rotatePoint(newX, p.y, newZ);
                let depth = map(rotated.z, -sphereRadius, sphereRadius, 0.4, 1);

                // Use particle's assigned color from palette, blended with overall blend
                let particleColor = params.colorPalette[p.colorIndex % params.colorPalette.length];
                let particleRgb = hexToRgb(particleColor);

                // Soft blend between particle color and overall blend for cohesion
                let r = lerp(particleRgb.r, blendedRgb.r, 0.4);
                let g = lerp(particleRgb.g, blendedRgb.g, 0.4);
                let b = lerp(particleRgb.b, blendedRgb.b, 0.4);

                // Soft glow effect for larger particles
                let glowSize = p.size * depth;

                // Outer glow
                fill(r, g, b, p.alpha * depth * 0.3);
                ellipse(rotated.x, rotated.y, glowSize * 2, glowSize * 2);

                // Core particle
                fill(r, g, b, p.alpha * depth);
                ellipse(rotated.x, rotated.y, glowSize, glowSize);

                // Add trail occasionally for ethereal feel
                if (i % 8 === 0 && random() < 0.05 && particleTrails.length < 100) {
                    particleTrails.push({
                        x: rotated.x,
                        y: rotated.y,
                        r: r,
                        g: g,
                        b: b,
                        size: glowSize * 1.2,
                        life: 40,
                        maxLife: 40
                    });
                }
            }
        }

        function updatePods() {
            for (let i = 0; i < pods.length; i++) {
                let pod = pods[i];

                // Update immunity timer for pods that just left
                if (pod.immunityTimer && pod.immunityTimer > 0) {
                    pod.immunityTimer--;
                    if (pod.immunityTimer <= 0) {
                        pod.justLeft = false;
                    }
                }

                // Find nearest pod for attraction
                let nearestDist = Infinity;
                let nearestPod = null;

                for (let j = 0; j < pods.length; j++) {
                    if (i === j) continue;
                    let other = pods[j];
                    let d = dist3D(pod, other);

                    if (d < nearestDist && d < 200) {
                        nearestDist = d;
                        nearestPod = other;
                    }
                }

                // Attraction to nearest pod
                if (nearestPod && nearestDist < 180) {
                    let attraction = params.attractionForce * 0.02;
                    // Stronger attraction for larger pods (chain reaction)
                    attraction *= (1 + pod.memberCount * 0.15);

                    pod.vx += (nearestPod.x - pod.x) * attraction / nearestDist;
                    pod.vy += (nearestPod.y - pod.y) * attraction / nearestDist;
                    pod.vz += (nearestPod.z - pod.z) * attraction / nearestDist;

                    pod.attracting = true;
                    pod.targetPod = nearestPod;

                    // Create energy bridge
                    if (nearestDist < 100 && random() < 0.12) {
                        energyBridges.push({
                            from: pod,
                            to: nearestPod,
                            progress: 0,
                            life: 30
                        });
                    }
                } else {
                    pod.attracting = false;
                    pod.targetPod = null;
                }

                // ═══════════════════════════════════════════════════════════════
                // DYNAMIC 3D MOVEMENT - More Z-axis motion
                // ═══════════════════════════════════════════════════════════════

                // Add 3D noise-based wandering for more dynamic movement
                let noiseScale = 0.008;
                let noiseTime = time * 0.5;
                let wanderStrength = 0.08 * params.podSpeed;

                // 3D Perlin noise for organic wandering in all directions
                let wanderX = (noise(pod.x * noiseScale, pod.y * noiseScale, noiseTime) - 0.5) * wanderStrength;
                let wanderY = (noise(pod.y * noiseScale, pod.z * noiseScale, noiseTime + 100) - 0.5) * wanderStrength;
                let wanderZ = (noise(pod.z * noiseScale, pod.x * noiseScale, noiseTime + 200) - 0.5) * wanderStrength;

                // Extra Z-axis impulse for dramatic front-back movement
                let zImpulse = sin(time * 0.8 + pod.phase * 2) * 0.03 * params.podSpeed;
                wanderZ += zImpulse;

                pod.vx += wanderX;
                pod.vy += wanderY;
                pod.vz += wanderZ;

                // Occasional random burst in Z direction
                if (random() < 0.005) {
                    pod.vz += (random() - 0.5) * 1.5;
                }

                // Keep pods inside sphere with soft boundary
                let distFromCenter = sqrt(pod.x * pod.x + pod.y * pod.y + pod.z * pod.z);
                if (distFromCenter > sphereRadius * 0.88) {
                    let pushBack = 0.04;
                    pod.vx -= pod.x / distFromCenter * pushBack;
                    pod.vy -= pod.y / distFromCenter * pushBack;
                    pod.vz -= pod.z / distFromCenter * pushBack;
                }

                // Prevent pods from getting too close to center
                if (distFromCenter < sphereRadius * 0.15) {
                    let pushOut = 0.03;
                    pod.vx += pod.x / distFromCenter * pushOut;
                    pod.vy += pod.y / distFromCenter * pushOut;
                    pod.vz += pod.z / distFromCenter * pushOut;
                }

                // Apply velocity with less damping for more dynamic movement
                pod.vx *= 0.96;
                pod.vy *= 0.96;
                pod.vz *= 0.96;

                // Higher max speed for more dynamic movement
                let speed = sqrt(pod.vx * pod.vx + pod.vy * pod.vy + pod.vz * pod.vz);
                let maxSpeed = 3.5 * params.podSpeed;
                if (speed > maxSpeed) {
                    pod.vx = (pod.vx / speed) * maxSpeed;
                    pod.vy = (pod.vy / speed) * maxSpeed;
                    pod.vz = (pod.vz / speed) * maxSpeed;
                }

                pod.x += pod.vx * params.podSpeed;
                pod.y += pod.vy * params.podSpeed;
                pod.z += pod.vz * params.podSpeed;

                pod.phase += pod.pulseSpeed;
            }
        }

        function drawPod(pod) {
            // Use rotated screen coordinates
            let screenX = pod.screenX;
            let screenY = pod.screenY;
            let screenZ = pod.screenZ;

            // Depth-based scaling for 3D effect
            let depthScale = map(screenZ, -sphereRadius, sphereRadius, 0.5, 1.3);
            let depthAlpha = map(screenZ, -sphereRadius, sphereRadius, 0.4, 1.0);

            let size = pod.size * depthScale;

            // Pulse animation
            let pulse = sin(pod.phase) * 0.1 + 1;
            size *= pulse;

            // Get blended color for multi-member pods
            let blendedColor = blendColors(pod.colors);
            let col = hexToRgb(blendedColor);

            noStroke();

            // Outer glow - stronger alpha for vivid color
            let glowLayers = 3;
            for (let i = glowLayers; i > 0; i--) {
                let glowSize = size * (1 + i * 0.4);
                let alpha = (1 - i / glowLayers) * 0.25 * depthAlpha;
                if (pod.attracting) alpha *= 1.3;
                fill(col.r, col.g, col.b, alpha);
                ellipse(screenX, screenY, glowSize, glowSize);
            }

            // Core - pure color, no white overlay
            if (pod.colors.length > 1) {
                // Multi-color pie segments for fused pods
                let segments = min(pod.colors.length, 6);
                for (let s = 0; s < segments; s++) {
                    let angle1 = (s / segments) * TWO_PI - PI / 2;
                    let angle2 = ((s + 1) / segments) * TWO_PI - PI / 2;

                    let segCol = hexToRgb(pod.colors[s % pod.colors.length]);

                    fill(segCol.r, segCol.g, segCol.b, depthAlpha);
                    arc(screenX, screenY, size, size, angle1, angle2, PIE);
                }
            } else {
                // Single color core - full opacity
                fill(col.r, col.g, col.b, depthAlpha);
                ellipse(screenX, screenY, size, size);
            }

            // Orbiting particles for larger pods
            if (pod.memberCount >= 3) {
                let orbitCount = min(pod.memberCount, 5);
                let orbitRadius = size * 0.65;

                for (let o = 0; o < orbitCount; o++) {
                    let orbitAngle = time * 1.5 + (o / orbitCount) * TWO_PI;
                    let orbX = screenX + cos(orbitAngle) * orbitRadius;
                    let orbY = screenY + sin(orbitAngle) * orbitRadius;

                    let orbCol = hexToRgb(pod.colors[o % pod.colors.length]);
                    fill(orbCol.r, orbCol.g, orbCol.b, 0.8 * depthAlpha);
                    ellipse(orbX, orbY, 5 * depthScale, 5 * depthScale);
                }
            }
        }

        function checkFusions() {
            for (let i = 0; i < pods.length; i++) {
                for (let j = i + 1; j < pods.length; j++) {
                    let podA = pods[i];
                    let podB = pods[j];
                    let d = dist3D(podA, podB);

                    if (d < params.fusionDistance) {
                        // Check immunity - recently left pods can't immediately rejoin
                        if (podA.justLeft || podB.justLeft) continue;

                        // FUSION!
                        fusePods(i, j);
                        return; // Only one fusion per frame
                    }
                }
            }
        }

        function fusePods(indexA, indexB) {
            let podA = pods[indexA];
            let podB = pods[indexB];

            // New position (weighted average by member count)
            let totalMembers = podA.memberCount + podB.memberCount;
            let newX = (podA.x * podA.memberCount + podB.x * podB.memberCount) / totalMembers;
            let newY = (podA.y * podA.memberCount + podB.y * podB.memberCount) / totalMembers;
            let newZ = (podA.z * podA.memberCount + podB.z * podB.memberCount) / totalMembers;

            // Combine colors (keep history)
            let newColors = [...podA.colors, ...podB.colors];
            if (newColors.length > 6) {
                // Keep most recent colors if too many
                newColors = newColors.slice(-6);
            }

            // Create fusion effect
            let rotatedA = rotatePoint(podA.x, podA.y, podA.z);
            let rotatedB = rotatePoint(podB.x, podB.y, podB.z);
            let rotatedNew = rotatePoint(newX, newY, newZ);

            fusionEffects.push({
                x: rotatedNew.x,
                y: rotatedNew.y,
                size: 0,
                maxSize: 150 + totalMembers * 20,
                colors: newColors,
                life: 40
            });

            // Remove old pods
            pods.splice(Math.max(indexA, indexB), 1);
            pods.splice(Math.min(indexA, indexB), 1);

            // Create new fused pod
            pods.push({
                x: newX,
                y: newY,
                z: newZ,
                vx: (podA.vx + podB.vx) * 0.5,
                vy: (podA.vy + podB.vy) * 0.5,
                vz: (podA.vz + podB.vz) * 0.5,
                colors: newColors,
                memberCount: totalMembers,
                size: 12 + totalMembers * 5,
                phase: 0,
                pulseSpeed: random(0.03, 0.06),
                targetPod: null,
                attracting: false
            });

            totalFusions++;

            // Spawn new single pods occasionally to keep the chain going
            if (pods.length < 4 || (random() < 0.3 && pods.length < params.initialPods)) {
                setTimeout(() => {
                    if (pods.length < params.initialPods) {
                        createPod(null, null);
                    }
                }, 500);
            }
        }

        function drawFusionEffects() {
            for (let i = fusionEffects.length - 1; i >= 0; i--) {
                let fx = fusionEffects[i];
                fx.life--;
                fx.size = lerp(fx.size, fx.maxSize, 0.1);

                if (fx.life <= 0) {
                    fusionEffects.splice(i, 1);
                    continue;
                }

                let alpha = fx.life / 40;
                let blended = blendColors(fx.colors);
                let col = hexToRgb(blended);

                // Simple soft glow only
                noStroke();
                fill(col.r, col.g, col.b, alpha * 0.1);
                ellipse(fx.x, fx.y, fx.size * 0.5, fx.size * 0.5);
            }
        }

        function checkLeaves() {
            for (let i = pods.length - 1; i >= 0; i--) {
                let pod = pods[i];

                // Only composite pods (2+ members) can have someone leave
                if (pod.memberCount < 2) continue;

                // Chance of leaving increases with pod size
                let leaveProb = params.leaveChance * (1 + (pod.memberCount - 2) * 0.3);

                if (random() < leaveProb) {
                    leavePod(i);
                    return; // Only one leave per frame
                }
            }
        }

        function leavePod(podIndex) {
            let pod = pods[podIndex];

            // Pick a random color to leave with
            let leaveColorIndex = floor(random(pod.colors.length));
            let leaveColor = pod.colors[leaveColorIndex];

            // Remove that color from the pod
            pod.colors.splice(leaveColorIndex, 1);
            pod.memberCount--;
            pod.size = 12 + pod.memberCount * 5;

            // Calculate leave direction (outward from pod)
            let leaveAngle = random(TWO_PI);
            let leavePhi = random(PI);
            let leaveDir = {
                x: sin(leavePhi) * cos(leaveAngle),
                y: sin(leavePhi) * sin(leaveAngle),
                z: cos(leavePhi)
            };

            // New position slightly offset from parent pod
            let offsetDist = pod.size + 30;
            let newX = pod.x + leaveDir.x * offsetDist;
            let newY = pod.y + leaveDir.y * offsetDist;
            let newZ = pod.z + leaveDir.z * offsetDist;

            // Keep within sphere bounds
            let distFromCenter = sqrt(newX * newX + newY * newY + newZ * newZ);
            if (distFromCenter > sphereRadius * 0.85) {
                let scale = (sphereRadius * 0.8) / distFromCenter;
                newX *= scale;
                newY *= scale;
                newZ *= scale;
            }

            // Create leave effect
            let rotatedPod = rotatePoint(pod.x, pod.y, pod.z);
            let rotatedNew = rotatePoint(newX, newY, newZ);

            leaveEffects.push({
                fromX: rotatedPod.x,
                fromY: rotatedPod.y,
                toX: rotatedNew.x,
                toY: rotatedNew.y,
                color: leaveColor,
                progress: 0,
                life: 50
            });

            // Create the new independent pod
            pods.push({
                x: newX,
                y: newY,
                z: newZ,
                vx: leaveDir.x * 1.5,
                vy: leaveDir.y * 1.5,
                vz: leaveDir.z * 1.5,
                colors: [leaveColor],
                memberCount: 1,
                size: 12,
                phase: random(TWO_PI),
                pulseSpeed: random(0.03, 0.06),
                targetPod: null,
                attracting: false,
                justLeft: true,  // Immunity period
                immunityTimer: 90  // Frames of immunity from rejoining
            });

            totalLeaves++;

            // If original pod is now empty (shouldn't happen but safety check)
            if (pod.memberCount <= 0) {
                pods.splice(podIndex, 1);
            }
        }

        function drawLeaveEffects() {
            for (let i = leaveEffects.length - 1; i >= 0; i--) {
                let fx = leaveEffects[i];
                fx.progress += 0.04;
                fx.life--;

                if (fx.life <= 0) {
                    leaveEffects.splice(i, 1);
                    continue;
                }

                let alpha = fx.life / 50;
                let col = hexToRgb(fx.color);

                // Trail from parent to new position
                let currentX = lerp(fx.fromX, fx.toX, min(fx.progress, 1));
                let currentY = lerp(fx.fromY, fx.toY, min(fx.progress, 1));

                // Fading trail
                let trailSteps = 15;
                for (let t = 0; t < trailSteps; t++) {
                    let trailProgress = max(0, fx.progress - t * 0.05);
                    if (trailProgress <= 0) continue;

                    let tx = lerp(fx.fromX, fx.toX, min(trailProgress, 1));
                    let ty = lerp(fx.fromY, fx.toY, min(trailProgress, 1));
                    let trailAlpha = alpha * (1 - t / trailSteps) * 0.6;

                    fill(col.r, col.g, col.b, trailAlpha);
                    noStroke();
                    ellipse(tx, ty, 8 - t * 0.4, 8 - t * 0.4);
                }

                // Main leaving particle
                if (fx.progress <= 1) {
                    // Glow
                    for (let g = 4; g > 0; g--) {
                        fill(col.r, col.g, col.b, alpha * 0.2 * (1 - g / 4));
                        ellipse(currentX, currentY, 20 + g * 8, 20 + g * 8);
                    }

                    // Core
                    fill(col.r, col.g, col.b, alpha * 0.9);
                    ellipse(currentX, currentY, 16, 16);

                    // Bright center
                    fill(255, 255, 255, alpha * 0.8);
                    ellipse(currentX, currentY, 6, 6);
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // Utility Functions
        // ═══════════════════════════════════════════════════════════════════════

        function dist3D(a, b) {
            return sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2 + (a.z - b.z) ** 2);
        }

        function hexToRgb(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }

        function blendColors(colors) {
            if (colors.length === 1) return colors[0];

            let r = 0, g = 0, b = 0;
            for (let c of colors) {
                let rgb = hexToRgb(c);
                r += rgb.r;
                g += rgb.g;
                b += rgb.b;
            }

            r = Math.round(r / colors.length);
            g = Math.round(g / colors.length);
            b = Math.round(b / colors.length);

            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        function updateStats() {
            document.getElementById('stat-pods').textContent = pods.length;
            document.getElementById('stat-fusions').textContent = totalFusions;
            document.getElementById('stat-leaves').textContent = totalLeaves;

            let largest = 1;
            for (let p of pods) {
                if (p.memberCount > largest) largest = p.memberCount;
            }
            document.getElementById('stat-largest').textContent = largest;
        }

        // ═══════════════════════════════════════════════════════════════════════
        // Color Presets
        // ═══════════════════════════════════════════════════════════════════════

        const colorPresets = {
            basic: [
                { name: 'Sakura', color: '#ffb7c5', harmony: 'analogous' },
                { name: 'Ocean', color: '#4a90d9', harmony: 'analogous' },
                { name: 'Sunset', color: '#ff7b54', harmony: 'analogous' },
                { name: 'Forest', color: '#5cb85c', harmony: 'analogous' },
                { name: 'Lavender', color: '#b088f4', harmony: 'analogous' },
                { name: 'Gold', color: '#ffd700', harmony: 'analogous' },
                { name: 'Coral', color: '#ff6b6b', harmony: 'complementary' },
                { name: 'Mint', color: '#64f4d4', harmony: 'analogous' }
            ],
            splatoon: [
                { name: 'Pink', color: '#f02d7d', harmony: 'complementary' },
                { name: 'Green', color: '#25d04a', harmony: 'complementary' },
                { name: 'Orange', color: '#f78f2e', harmony: 'tetradic' },
                { name: 'Purple', color: '#7b4fbf', harmony: 'triadic' }
            ]
        };

        function renderPresets() {
            // Render each category
            renderPresetCategory('preset-basic', colorPresets.basic);
            renderPresetCategory('preset-splatoon', colorPresets.splatoon);
        }

        function renderPresetCategory(containerId, presets) {
            let container = document.getElementById(containerId);
            container.innerHTML = '';

            for (let preset of presets) {
                let btn = document.createElement('div');
                btn.className = 'preset-btn';
                if (params.themeColor === preset.color) {
                    btn.classList.add('active');
                }
                btn.onclick = () => selectPreset(preset);

                let swatch = document.createElement('div');
                swatch.className = 'preset-swatch';
                swatch.style.backgroundColor = preset.color;

                let name = document.createElement('div');
                name.className = 'preset-name';
                name.textContent = preset.name;

                btn.appendChild(swatch);
                btn.appendChild(name);
                container.appendChild(btn);
            }
        }

        function selectPreset(preset) {
            params.themeColor = preset.color;
            params.colorHarmony = preset.harmony;
            document.getElementById('color-harmony').value = preset.harmony;
            params.colorPalette = generatePalette(preset.color, preset.harmony);
            updatePalettePreview();
            renderPresets();
            initializeSystem();
        }

        // ═══════════════════════════════════════════════════════════════════════
        // Color Palette Generation
        // ═══════════════════════════════════════════════════════════════════════

        function hexToHsl(hex) {
            let rgb = hexToRgb(hex);
            let r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToHex(h, s, l) {
            h = ((h % 360) + 360) % 360;
            s = Math.max(0, Math.min(100, s)) / 100;
            l = Math.max(0, Math.min(100, l)) / 100;

            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r, g, b;

            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        function generatePalette(baseColor, harmony) {
            let hsl = hexToHsl(baseColor);
            let palette = [];

            switch (harmony) {
                case 'analogous':
                    // 類似色: 彩度維持、色相のみ変化
                    palette = [
                        hslToHex(hsl.h - 30, hsl.s, hsl.l),
                        hslToHex(hsl.h - 15, hsl.s, hsl.l),
                        baseColor,
                        hslToHex(hsl.h + 15, hsl.s, hsl.l),
                        hslToHex(hsl.h + 30, hsl.s, hsl.l),
                        hslToHex(hsl.h - 20, hsl.s, hsl.l),
                        hslToHex(hsl.h + 20, hsl.s, hsl.l),
                        hslToHex(hsl.h - 10, hsl.s, hsl.l)
                    ];
                    break;

                case 'complementary':
                    // 補色: 彩度維持
                    let comp = (hsl.h + 180) % 360;
                    palette = [
                        baseColor,
                        hslToHex(hsl.h + 10, hsl.s, hsl.l),
                        hslToHex(hsl.h - 10, hsl.s, hsl.l),
                        hslToHex(comp, hsl.s, hsl.l),
                        hslToHex(comp + 10, hsl.s, hsl.l),
                        hslToHex(comp - 10, hsl.s, hsl.l),
                        hslToHex(hsl.h + 15, hsl.s, hsl.l),
                        hslToHex(comp + 15, hsl.s, hsl.l)
                    ];
                    break;

                case 'triadic':
                    // 三色: 彩度維持
                    palette = [
                        baseColor,
                        hslToHex(hsl.h + 10, hsl.s, hsl.l),
                        hslToHex(hsl.h + 120, hsl.s, hsl.l),
                        hslToHex(hsl.h + 130, hsl.s, hsl.l),
                        hslToHex(hsl.h + 240, hsl.s, hsl.l),
                        hslToHex(hsl.h + 250, hsl.s, hsl.l),
                        hslToHex(hsl.h + 60, hsl.s, hsl.l),
                        hslToHex(hsl.h + 180, hsl.s, hsl.l)
                    ];
                    break;

                case 'tetradic':
                    // 四色: 彩度維持
                    palette = [
                        baseColor,
                        hslToHex(hsl.h + 90, hsl.s, hsl.l),
                        hslToHex(hsl.h + 180, hsl.s, hsl.l),
                        hslToHex(hsl.h + 270, hsl.s, hsl.l),
                        hslToHex(hsl.h + 45, hsl.s, hsl.l),
                        hslToHex(hsl.h + 135, hsl.s, hsl.l),
                        hslToHex(hsl.h + 225, hsl.s, hsl.l),
                        hslToHex(hsl.h + 315, hsl.s, hsl.l)
                    ];
                    break;

                case 'monochromatic':
                    // 同系色: 彩度維持、明度のみ微調整
                    palette = [
                        hslToHex(hsl.h, hsl.s, hsl.l - 10),
                        hslToHex(hsl.h, hsl.s, hsl.l - 5),
                        baseColor,
                        hslToHex(hsl.h, hsl.s, hsl.l + 5),
                        hslToHex(hsl.h, hsl.s, hsl.l + 10),
                        hslToHex(hsl.h + 5, hsl.s, hsl.l),
                        hslToHex(hsl.h - 5, hsl.s, hsl.l),
                        hslToHex(hsl.h, hsl.s, hsl.l)
                    ];
                    break;

                default:
                    palette = [baseColor];
            }

            return palette;
        }

        function updatePalettePreview() {
            let preview = document.getElementById('palette-preview');
            preview.innerHTML = '';

            for (let color of params.colorPalette) {
                let swatch = document.createElement('div');
                swatch.className = 'palette-color';
                swatch.style.backgroundColor = color;
                swatch.title = color;
                preview.appendChild(swatch);
            }
        }

        function updateThemeColor(color) {
            params.themeColor = color;
            document.getElementById('theme-color-value').textContent = color;
            params.colorPalette = generatePalette(color, params.colorHarmony);
            updatePalettePreview();
            initializeSystem();
        }

        function updateColorHarmony(harmony) {
            params.colorHarmony = harmony;
            params.colorPalette = generatePalette(params.themeColor, harmony);
            updatePalettePreview();
            initializeSystem();
        }

        // ═══════════════════════════════════════════════════════════════════════
        // UI Handlers
        // ═══════════════════════════════════════════════════════════════════════

        function updateParam(paramName, value) {
            params[paramName] = parseFloat(value);
            document.getElementById(paramName + '-value').textContent = value;
            if (paramName === 'initialPods') {
                initializeSystem();
            }
        }

        function updateSeedDisplay() {
            document.getElementById('seed-input').value = params.seed;
        }

        function updateSeed() {
            let newSeed = parseInt(document.getElementById('seed-input').value);
            if (newSeed && newSeed > 0) {
                params.seed = newSeed;
                initializeSystem();
            } else {
                updateSeedDisplay();
            }
        }

        function previousSeed() {
            params.seed = Math.max(1, params.seed - 1);
            updateSeedDisplay();
            initializeSystem();
        }

        function nextSeed() {
            params.seed++;
            updateSeedDisplay();
            initializeSystem();
        }

        function randomSeedAndUpdate() {
            params.seed = Math.floor(Math.random() * 999999) + 1;
            updateSeedDisplay();
            initializeSystem();
        }

        function resetParameters() {
            params = JSON.parse(JSON.stringify(defaultParams));

            document.getElementById('initialPods').value = params.initialPods;
            document.getElementById('initialPods-value').textContent = params.initialPods;
            document.getElementById('rotationSpeed').value = params.rotationSpeed;
            document.getElementById('rotationSpeed-value').textContent = params.rotationSpeed;
            document.getElementById('fusionDistance').value = params.fusionDistance;
            document.getElementById('fusionDistance-value').textContent = params.fusionDistance;
            document.getElementById('attractionForce').value = params.attractionForce;
            document.getElementById('attractionForce-value').textContent = params.attractionForce;
            document.getElementById('podSpeed').value = params.podSpeed;
            document.getElementById('podSpeed-value').textContent = params.podSpeed;
            document.getElementById('leaveChance').value = params.leaveChance;
            document.getElementById('leaveChance-value').textContent = params.leaveChance;

            // Reset theme color
            document.getElementById('theme-color').value = params.themeColor;
            document.getElementById('theme-color-value').textContent = params.themeColor;
            document.getElementById('color-harmony').value = params.colorHarmony;
            initializeColorSystem();

            updateSeedDisplay();
            initializeSystem();
        }

        function downloadImage() {
            saveCanvas('pod-fusion-' + params.seed, 'png');
        }

        function initializeColorSystem() {
            params.colorPalette = generatePalette(params.themeColor, params.colorHarmony);
            updatePalettePreview();
            renderPresets();
        }

        window.addEventListener('load', () => {
            updateSeedDisplay();
            initializeColorSystem();
        });
    </script>
</body>
</html>
